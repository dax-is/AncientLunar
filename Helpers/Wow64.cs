using AncientLunar.Extensions;
using AncientLunar.Native.Enums;
using AncientLunar.Native.PInvoke;
using AncientLunar.Native.Structs;
using AncientLunar.PortableExecutable;
using AncientLunar.Remote.Structs;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace AncientLunar.Helpers
{
    internal static unsafe class Wow64
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate ulong GetTeb64Proc();

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate ulong CreateThread64Proc(CreateThreadContext* data);

        private static readonly byte[] getteb64 = new byte[]
        {
            0x55, 0x8b, 0xec, 0x83, 0xec, 0x08, 0x53, 0x56, 0x57, 0x0f, 0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 
            0xf8, 0x6a, 0x33, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x83, 0x04, 0x24, 0x05, 0xcb, 0x49, 0x54, 0x8f, 
            0x45, 0xf8, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x04, 0x23, 0x00, 0x00, 0x00, 0x83, 
            0x04, 0x24, 0x0d, 0xcb, 0x8b, 0x45, 0xf8, 0x8b, 0x55, 0xfc, 0x5f, 0x5e, 0x5b, 0x8b, 0xe5, 0x5d,
            0xc3,
        };

        private static readonly byte[] createthread64 = new byte[]
        {
            0x55, 0x8b, 0xec, 0x6a, 0x00, 0x6a, 0x00, 0x8b, 0x45, 0x08, 0x83, 0xc0, 0x18, 0x99, 0x52, 0x50,
            0x6a, 0x00, 0x6a, 0x00, 0x8b, 0x45, 0x08, 0x8b, 0x48, 0x14, 0x51, 0x8b, 0x50, 0x10, 0x52, 0x6a,
            0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a,
            0x00, 0x6a, 0x00, 0x8b, 0x45, 0x08, 0x8b, 0x48, 0x0c, 0x51, 0x8b, 0x50, 0x08, 0x52, 0x6a, 0x0a,
            0x8b, 0x45, 0x08, 0x8b, 0x48, 0x04, 0x51, 0x8b, 0x10, 0x52, 
            0xe8, 0x00, 0x00, 0x00, 0x00, // call 0x00000000 (placeholder) (0x4B)
            0x83, 0xc4, 0x5c, 0x5d, 0xc3,
        };

        private static readonly byte[] execute64 = new byte[]
        {
            0x55, 0x8b, 0xec, 0x83, 0xec, 0x64, 0x53, 0x56, 0x57, 0x8d, 0x45, 0x14, 0x89, 0x45, 0xf8, 0x83,
            0x7d, 0x10, 0x00, 0x7e, 0x23, 0x8b, 0x4d, 0x10, 0x83, 0xe9, 0x01, 0x89, 0x4d, 0x10, 0x8b, 0x55,
            0xf8, 0x83, 0xc2, 0x08, 0x89, 0x55, 0xf8, 0x8b, 0x45, 0xf8, 0x8b, 0x48, 0xf8, 0x8b, 0x50, 0xfc,
            0x89, 0x4d, 0xec, 0x89, 0x55, 0xf0, 0xeb, 0x08, 0x0f, 0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 0xec,
            0x8b, 0x45, 0xec, 0x8b, 0x4d, 0xf0, 0x89, 0x45, 0xbc, 0x89, 0x4d, 0xc0, 0x83, 0x7d, 0x10, 0x00,
            0x7e, 0x23, 0x8b, 0x55, 0x10, 0x83, 0xea, 0x01, 0x89, 0x55, 0x10, 0x8b, 0x45, 0xf8, 0x83, 0xc0,
            0x08, 0x89, 0x45, 0xf8, 0x8b, 0x4d, 0xf8, 0x8b, 0x51, 0xf8, 0x8b, 0x41, 0xfc, 0x89, 0x55, 0xe4,
            0x89, 0x45, 0xe8, 0xeb, 0x08, 0x0f, 0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 0xe4, 0x8b, 0x4d, 0xe4,
            0x8b, 0x55, 0xe8, 0x89, 0x4d, 0xb4, 0x89, 0x55, 0xb8, 0x83, 0x7d, 0x10, 0x00, 0x7e, 0x23, 0x8b,
            0x45, 0x10, 0x83, 0xe8, 0x01, 0x89, 0x45, 0x10, 0x8b, 0x4d, 0xf8, 0x83, 0xc1, 0x08, 0x89, 0x4d,
            0xf8, 0x8b, 0x55, 0xf8, 0x8b, 0x42, 0xf8, 0x8b, 0x4a, 0xfc, 0x89, 0x45, 0xdc, 0x89, 0x4d, 0xe0,
            0xeb, 0x08, 0x0f, 0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 0xdc, 0x8b, 0x55, 0xdc, 0x8b, 0x45, 0xe0,
            0x89, 0x55, 0xac, 0x89, 0x45, 0xb0, 0x83, 0x7d, 0x10, 0x00, 0x7e, 0x23, 0x8b, 0x4d, 0x10, 0x83,
            0xe9, 0x01, 0x89, 0x4d, 0x10, 0x8b, 0x55, 0xf8, 0x83, 0xc2, 0x08, 0x89, 0x55, 0xf8, 0x8b, 0x45,
            0xf8, 0x8b, 0x48, 0xf8, 0x8b, 0x50, 0xfc, 0x89, 0x4d, 0xd4, 0x89, 0x55, 0xd8, 0xeb, 0x08, 0x0f,
            0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 0xd4, 0x8b, 0x45, 0xd4, 0x8b, 0x4d, 0xd8, 0x89, 0x45, 0xa4,
            0x89, 0x4d, 0xa8, 0x0f, 0x57, 0xc0, 0x66, 0x0f, 0x13, 0x45, 0xc4, 0x8b, 0x55, 0xf8, 0x83, 0xc2,
            0x08, 0x89, 0x55, 0xf8, 0x8b, 0x45, 0xf8, 0x83, 0xe8, 0x08, 0x99, 0x89, 0x45, 0x9c, 0x89, 0x55,
            0xa0, 0x8b, 0x45, 0x10, 0x99, 0x89, 0x45, 0xcc, 0x89, 0x55, 0xd0, 0xc7, 0x45, 0xf4, 0x00, 0x00,
            0x00, 0x00, 0x33, 0xc0, 0x66, 0x89, 0x45, 0xfc, 0x66, 0x8c, 0x65, 0xfc, 0xb8, 0x2b, 0x00, 0x00,
            0x00, 0x66, 0x8e, 0xe0, 0x89, 0x65, 0xf4, 0x83, 0xe4, 0xf0, 0x6a, 0x33, 0xe8, 0x00, 0x00, 0x00,
            0x00, 0x83, 0x04, 0x24, 0x05, 0xcb, 0x48, 0x8b, 0x4d, 0xbc, 0x48, 0x8b, 0x55, 0xb4, 0xff, 0x75,
            0xac, 0x49, 0x58, 0xff, 0x75, 0xa4, 0x49, 0x59, 0x48, 0x8b, 0x45, 0xcc, 0xa8, 0x01, 0x75, 0x03,
            0x83, 0xec, 0x08, 0x57, 0x48, 0x8b, 0x7d, 0x9c, 0x48, 0x85, 0xc0, 0x74, 0x16, 0x48, 0x8d, 0x7c,
            0xc7, 0xf8, 0x48, 0x85, 0xc0, 0x74, 0x0c, 0xff, 0x37, 0x48, 0x83, 0xef, 0x08, 0x48, 0x83, 0xe8,
            0x01, 0xeb, 0xef, 0x48, 0x83, 0xec, 0x20, 0xff, 0x55, 0x08, 0x48, 0x8b, 0x4d, 0xcc, 0x48, 0x8d,
            0x64, 0xcc, 0x20, 0x5f, 0x48, 0x89, 0x45, 0xc4, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24,
            0x04, 0x23, 0x00, 0x00, 0x00, 0x83, 0x04, 0x24, 0x0d, 0xcb, 0x66, 0x8c, 0xd8, 0x66, 0x8e, 0xd0,
            0x8b, 0x65, 0xf4, 0x66, 0x8b, 0x45, 0xfc, 0x66, 0x8e, 0xe0, 0x8b, 0x45, 0xc4, 0x8b, 0x55, 0xc8,
            0x5f, 0x5e, 0x5b, 0x8b, 0xe5, 0x5d, 0xc3, 
        };

        private static readonly GetTeb64Proc GetTeb64Fn;
        private static readonly CreateThread64Proc CreateThread64Fn;

        private static readonly ulong lpRtlCreateUserThread;

        static Wow64()
        {
            var pGetTeb64 = Kernel32.VirtualAlloc(IntPtr.Zero, (IntPtr)getteb64.Length, AllocationType.Commit | AllocationType.Reserve, ProtectionType.ExecuteReadWrite);
            var pCreateThread64 = Kernel32.VirtualAlloc(IntPtr.Zero, (IntPtr)createthread64.Length, AllocationType.Commit | AllocationType.Reserve, ProtectionType.ExecuteReadWrite);
            var pExecute64 = Kernel32.VirtualAlloc(IntPtr.Zero, (IntPtr)execute64.Length, AllocationType.Commit | AllocationType.Reserve, ProtectionType.ExecuteReadWrite);

            Marshal.Copy(getteb64, 0, pGetTeb64, getteb64.Length);
            Marshal.Copy(createthread64, 0, pCreateThread64, createthread64.Length);
            Marshal.Copy(execute64, 0, pExecute64, execute64.Length);

            // Copy function pointer for Execute64 to CreateThread64 shellcode
            Marshal.Copy(BitConverter.GetBytes((uint)pExecute64 - ((uint)pCreateThread64 + 0x4F)), 0, (IntPtr)((uint)pCreateThread64 + 0x4B), 4);

            GetTeb64Fn = (GetTeb64Proc)Marshal.GetDelegateForFunctionPointer(pGetTeb64, typeof(GetTeb64Proc));
            CreateThread64Fn = (CreateThread64Proc)Marshal.GetDelegateForFunctionPointer(pCreateThread64, typeof(CreateThread64Proc));

            var ntdll = GetNtdllModuleWow64();
            var fn = ntdll.PEImage.ExportDirectory.GetExportedFunction("RtlCreateUserThread");

            lpRtlCreateUserThread = ntdll.Address + (ulong)fn.Value.RelativeAddress;
        }

        public static IEnumerable<ModuleInfo> EnumModules(Process process, ulong pebAddress)
        {
            var peb = process.ReadWow64Memory<Peb64>(pebAddress);
            var ldr = process.ReadWow64Memory<PebLdrData64>(peb.LoaderData);

            var firstEntry = ldr.InLoadOrderModuleList.Flink;
            var entry = firstEntry;

            do
            {
                var ldrEntry = process.ReadWow64Memory<LdrDataTableEntry64>(entry);
                var moduleName = process.ReadUnicodeString(ldrEntry.FullDllName);

                yield return new ModuleInfo((ulong)ldrEntry.DllBase, moduleName);

                entry = ldrEntry.InLoadOrderLinks.Flink;
            } while (entry != firstEntry);
        }

        public static Teb64 GetTeb64()
        {
            var ptr = GetTeb64Fn();
            var process = Process.GetCurrentProcess();

            return process.ReadWow64Memory<Teb64>(ptr);
        }

        public static Module GetNtdllModuleWow64()
        {
            using (var process = Process.GetCurrentProcess())
            {
                var teb = GetTeb64();
                var module = EnumModules(process, teb.ProcessEnvironmentBlock).FirstOrDefault(mod => Path.GetFileName(mod.FileName).Equals("ntdll.dll", StringComparison.OrdinalIgnoreCase));

                var fileName = module.FileName.ToLowerInvariant().Replace("system32", "sysnative");

                return new Module(module.Address, new PEImage(new ArraySegment<byte>(File.ReadAllBytes(fileName))));
            }
        }

        public static NtStatus CreateRemoteThread(IntPtr processHandle, ulong lpStartAddress, out IntPtr threadHandle)
        {
            var context = new CreateThreadContext
            {
                RtlCreateUserThreadPtr = lpRtlCreateUserThread,
                ProcessHandle = (ulong)processHandle,
                ThreadEntryPoint = lpStartAddress,
                ThreadHandle = 0
            };

            var result = CreateThread64Fn(&context);

            threadHandle = (IntPtr)context.ThreadHandle;

            return new NtStatus((uint)result);
        }

        private struct CreateThreadContext
        {
            public ulong RtlCreateUserThreadPtr;
            public ulong ProcessHandle;
            public ulong ThreadEntryPoint;
            public ulong ThreadHandle;
        }
    }
}
